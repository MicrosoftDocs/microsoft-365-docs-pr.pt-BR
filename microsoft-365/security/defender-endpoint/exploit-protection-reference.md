---
title: Referência de proteção de exploração
keywords: mitigações, vulnerabilidades, vulnerabilidades, mitigação, exploração, explorações, emet
description: Detalhes sobre como o recurso de proteção de exploração funciona no Windows 10
search.product: eADQiWindows 10XVcnh
ms.pagetype: security
ms.prod: m365-security
ms.mktglfcycl: manage
ms.sitesec: library
localization_priority: Normal
audience: ITPro
author: denisebmsft
ms.author: deniseb
ms.date: 01/06/2021
ms.reviewer: cjacks
manager: dansimp
ms.custom: asr
ms.technology: mde
ms.topic: article
ms.openlocfilehash: a87215b0e23d56a73259bbee4600ec9e15a27f3b
ms.sourcegitcommit: dcb97fbfdae52960ae62b6faa707a05358193ed5
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 03/25/2021
ms.locfileid: "51199340"
---
# <a name="exploit-protection-reference"></a>Referência de Proteção de Exploração

[!INCLUDE [Microsoft 365 Defender rebranding](../../includes/microsoft-defender.md)]


**Aplica-se a:**
- [Microsoft Defender para Ponto de Extremidade](https://go.microsoft.com/fwlink/?linkid=2154037)
- [Microsoft 365 Defender](https://go.microsoft.com/fwlink/?linkid=2118804)

>Deseja experimentar o Microsoft Defender para Ponto de Extremidade? [Inscreva-se para uma avaliação gratuita.](https://www.microsoft.com/microsoft-365/windows/microsoft-defender-atp?ocid=docs-wdatp-enablesiem-abovefoldlink)

A proteção de exploração fornece proteções avançadas para aplicativos que o Profissional de IT pode aplicar depois que o desenvolvedor compilou e distribuiu o software.

Este artigo ajuda você a entender como funciona a proteção de exploração, no nível da política e no nível de mitigação individual, para ajudá-lo a criar e aplicar políticas de Proteção de Exploração com êxito.

## <a name="how-mitigations-are-applied"></a>Como as mitigações são aplicadas

As mitigações do Exploit Protection são aplicadas por aplicativo.

As mitigações são configuradas por meio de uma entrada do Registro para cada programa para o que você configura proteções. Essas configurações são armazenadas na entrada do Registro **MitigationOptions** para cada programa (**HKEY_LOCAL_MACHINE \ SOFTWARE \ Microsoft \ Windows NT \ CurrentVersion \ Image File Execution Options \ *ImageFileName* \ MitigationOptions**). Eles fazem efeito quando você reinicia o programa e permanece em vigor até que você os altere e reinicie o programa novamente.

> [!IMPORTANT]
> As Opções de Execução de Arquivo de Imagem permitem apenas que você especifique um nome de arquivo ou caminho, e não um número de versão, arquitetura ou qualquer outro diferencial. Tenha cuidado para direcionar mitigações a aplicativos que têm nomes ou caminhos exclusivos, aplicando-os apenas em dispositivos em que você testou essa versão e essa arquitetura do aplicativo.

Se você configurar mitigações de proteção de exploração usando um arquivo de configuração XML, por meio do PowerShell, da Política de Grupo ou do MDM, ao processar esse arquivo de configuração XML, as configurações individuais do Registro serão configuradas para você.

Quando a política de distribuição do arquivo XML não for mais imposta, as configurações implantadas por esse arquivo de configuração XML não serão removidas automaticamente. Para remover as configurações do Exploit Protection, exporte a configuração XML de um dispositivo Windows 10 limpo e implante esse novo arquivo XML. Como alternativa, a Microsoft fornece um arquivo XML como parte das Linhas de Base de Segurança do Windows para redefinir as configurações do Exploit Protection.

Para redefinir as configurações de proteção de exploração usando o PowerShell, você pode usar o seguinte comando:

```powershell
Set-ProcessMitigation -PolicyFilePath EP-reset.xml
```
A seguir está o EP-reset.xml distribuído com as Linhas de Base de Segurança do Windows:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<MitigationPolicy>
  <AppConfig Executable="ONEDRIVE.EXE">
    <DEP OverrideDEP="false" />
    <ASLR OverrideRelocateImages="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
  </AppConfig>
  <AppConfig Executable="firefox.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
  </AppConfig>
  <AppConfig Executable="fltldr.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
    <ChildProcess OverrideChildProcess="false" />
  </AppConfig>
  <AppConfig Executable="GROOVE.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
    <ChildProcess OverrideChildProcess="false" />
  </AppConfig>
  <AppConfig Executable="Acrobat.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="AcroRd32.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="chrome.exe">
    <DEP OverrideDEP="false" />
  </AppConfig>
  <AppConfig Executable="EXCEL.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="iexplore.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="INFOPATH.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="java.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="javaw.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="javaws.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="LYNC.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="MSACCESS.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="MSPUB.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="OIS.EXE">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="OUTLOOK.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="plugin-container.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="POWERPNT.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="PPTVIEW.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="VISIO.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="VPREVIEW.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="WINWORD.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="wmplayer.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="wordpad.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
</MitigationPolicy>
```

## <a name="mitigation-reference"></a>Referência de mitigação

As seções a seguir detalham as proteções fornecidas por cada mitigação de proteção de exploração, as considerações de compatibilidade para a mitigação e as opções de configuração disponíveis.

## <a name="arbitrary-code-guard"></a>Proteção de código arbitrário

### <a name="description"></a>Descrição

O proteção de código arbitrário ajuda a proteger contra um invasor mal-intencionado carregando o código de sua escolha na memória por meio de uma vulnerabilidade de segurança de memória e podendo executar esse código.

O proteção de código arbitrário protege um aplicativo contra a execução de código gerado dinamicamente (código que não é carregado, por exemplo, do exe em si ou de uma dll). O code guard arbitrário funciona impedindo que a memória seja marcada como executável. Quando um aplicativo tenta [alocar memória,](https://docs.microsoft.com/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)verificamos os sinalizadores de proteção. (A memória pode ser alocada com sinalizadores de proteção de leitura, gravação e/ou execução.) Se a alocação tentar incluir o sinalizador de proteção [*de*](https://docs.microsoft.com/windows/win32/memory/memory-protection-constants) execução, a alocação de memória falhará e retornará um código de erro (STATUS_DYNAMIC_CODE_BLOCKED). Da mesma forma, se [](https://docs.microsoft.com/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect) um aplicativo tentar alterar os sinalizadores de proteção [](https://docs.microsoft.com/windows/win32/memory/memory-protection-constants) da memória que já foram alocados e inclui o sinalizador de proteção de execução, a alteração de permissão falhará e retornará um código de erro (STATUS_DYNAMIC_CODE_BLOCKED).

Ao impedir que o sinalizador *de* execução seja definido, o recurso de prevenção de execução de dados do Windows 10 pode, em seguida, proteger contra o ponteiro de instrução que está sendo definido para essa memória e executar esse código.

### <a name="compatibility-considerations"></a>Considerações sobre compatibilidade

O code guard arbitrário impede a alocação de qualquer memória como executável, o que apresenta um problema de compatibilidade com abordagens como compiladores just-in-time (JIT). A maioria dos navegadores modernos, por exemplo, compila JavaScript em código nativo para otimizar o desempenho. Para dar suporte a essa mitigação, eles precisarão ser rearmados para mover a compilação JIT para fora do processo protegido. Outros aplicativos cujo design gera dinamicamente código a partir de scripts ou outros idiomas intermediários serão incompatíveis com essa mitigação.

### <a name="configuration-options"></a>Opções de configuração

**Permitir a aceitação de threads** - Você pode configurar a mitigação para permitir que um thread individual opte por essa proteção. O desenvolvedor deve ter escrito o aplicativo com reconhecimento dessa mitigação e ter chamado a API [**SetThreadInformation**](https://docs.microsoft.com/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadinformation) com o parâmetro *ThreadInformation* definido como **ThreadDynamicCodePolicy** para poder executar o código dinâmico neste thread.

**Somente auditoria** - Você pode habilitar essa mitigação no modo de auditoria para medir o impacto potencial da compatibilidade em um aplicativo. Os eventos de auditoria podem ser exibidos no visualizador de eventos ou usando a Busca Avançada no [Defender para o Ponto de Extremidade.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="block-low-integrity-images"></a>Bloquear imagens de baixa integridade

### <a name="description"></a>Descrição

Bloquear imagens de baixa integridade impede que o aplicativo carregue arquivos que não sejam de confiança, normalmente porque eles foram baixados da Internet de um navegador em áreas de segurança.

Essa mitigação bloqueará as cargas de imagem se a imagem tiver uma Ace (Entrada de Controle de Acesso) que conceda acesso a processos de Baixa IL e que não tenha um ACE de rótulo de confiança. Ele é implementado pelo gerenciador de memória, que impede que o arquivo seja mapeado na memória. Se um aplicativo tentar mapear uma imagem de baixa integridade, ele disparará um STATUS_ACCESS_DENIED erro. Para obter detalhes sobre como funcionam os níveis de integridade, consulte [Controle obrigatório de integridade.](https://docs.microsoft.com/windows/win32/secauthz/mandatory-integrity-control)

### <a name="compatibility-considerations"></a>Considerações sobre compatibilidade

Bloquear imagens de baixa integridade impedirá que o aplicativo carregue arquivos baixados da Internet. Se o fluxo de trabalho do aplicativo exigir o carregamento de imagens baixadas, você vai querer garantir que elas sejam baixadas de um processo de confiança mais alta ou sejam explicitamente rotuladas para aplicar essa mitigação.

### <a name="configuration-options"></a>Opções de configuração

**Somente auditoria** - Você pode habilitar essa mitigação no modo de auditoria para medir o impacto potencial da compatibilidade em um aplicativo. Os eventos de auditoria podem ser exibidos no visualizador de eventos ou usando a Busca Avançada no [Microsoft Defender para Ponto de Extremidade.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="block-remote-images"></a>Bloquear imagens remotas

### <a name="description"></a>Descrição

O bloqueio de imagens remotas ajuda a impedir que o aplicativo carrega arquivos hospedados em um dispositivo remoto, como um compartilhamento UNC. O bloqueio de imagens remotas ajuda a proteger contra carregar binários na memória que estão em um dispositivo externo controlado pelo invasor.

Essa mitigação bloqueará cargas de imagem se a imagem for determinada em um dispositivo remoto. Ele é implementado pelo gerenciador de memória, que impede que o arquivo seja mapeado na memória. Se um aplicativo tentar mapear um arquivo remoto, ele disparará um STATUS_ACCESS_DENIED erro.

### <a name="compatibility-considerations"></a>Considerações sobre compatibilidade

Bloquear imagens remotas impedirá que o aplicativo carrega imagens de dispositivos remotos. Se o aplicativo carregar arquivos ou plug-ins de dispositivos remotos, ele não será compatível com essa mitigação.

### <a name="configuration-options"></a>Opções de configuração

**Somente auditoria** - Você pode habilitar essa mitigação no modo de auditoria para medir o impacto potencial da compatibilidade em um aplicativo. Os eventos de auditoria podem ser exibidos no visualizador de eventos ou usando a Busca Avançada no [Microsoft Defender para Ponto de Extremidade.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="block-untrusted-fonts"></a>Bloquear fontes não confianças

### <a name="description"></a>Descrição

O bloqueio de fontes nãotrudas reduz o risco de uma falha na análise de fonte que leva o invasor a executar código no dispositivo. Somente fontes instaladas no diretório windows\fonts serão carregadas para processamento pela GDI.

Essa mitigação é implementada no GDI, que valida o local do arquivo. Se o arquivo não estiver no diretório de fontes do sistema, a fonte não será carregada para análise e essa chamada falhará.

Essa mitigação é além da mitigação interna fornecida no Windows 10 1607 e posterior, que move a análise de fonte para fora do kernel e para um contêiner de aplicativo no modo de usuário. Qualquer exploração baseada na análise de fonte, como resultado, acontece em um contexto isolado e em áreas de áreas de risco, o que reduz significativamente o risco. Para obter detalhes sobre essa mitigação, consulte o blog [Hardening Windows 10 with zero-day exploit mitigations](https://www.microsoft.com/security/blog/2017/01/13/hardening-windows-10-with-zero-day-exploit-mitigations/).

### <a name="compatibility-considerations"></a>Considerações sobre compatibilidade

O uso mais comum de fontes fora do diretório de fontes do sistema é com [fontes da Web](https://docs.microsoft.com/typography/fonts/font-faq#web). Os navegadores modernos, como o Microsoft Edge, usam DirectWrite em vez de GDI e não são afetados. No entanto, navegadores herdados, como o Internet Explorer 11 (e o modo IE no novo Microsoft Edge) podem ser afetados, especialmente com aplicativos como o Office 365, que usam glifos de fonte para exibir a interface do usuário.

### <a name="configuration-options"></a>Opções de configuração

**Somente auditoria** - Você pode habilitar essa mitigação no modo de auditoria para medir o impacto potencial da compatibilidade em um aplicativo. Os eventos de auditoria podem ser exibidos no visualizador de eventos ou usando a Busca Avançada no [Microsoft Defender para Ponto de Extremidade.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="code-integrity-guard"></a>Proteção de integridade de código

### <a name="description"></a>Descrição

O Code integrity guard garante que todos os binários carregados em um processo sejam assinados digitalmente pela Microsoft. O Code integrity guard inclui [assinaturas WHQL](https://docs.microsoft.com/windows-hardware/drivers/install/whql-release-signature) (Laboratórios de Qualidade de Hardware do Windows), o que permitirá que drivers aprovados pelo WHQL executem dentro do processo.

Essa mitigação é implementada no gerenciador de memória, o que impede que o binário seja mapeado na memória. Se você tentar carregar um binário não assinado pela Microsoft, o manger de memória retornará o erro STATUS_INVALID_IMAGE_HASH. Ao bloquear no nível do gerenciador de memória, isso impede que binários carregados pelo processo e binários injetados no processo.

### <a name="compatibility-considerations"></a>Considerações sobre compatibilidade

Essa mitigação bloqueia especificamente qualquer binário que não seja assinado pela Microsoft. Dessa forma, ele será incompatível com a maioria dos softwares de terceiros, a menos que esse software seja distribuído pela Microsoft Store (e assinado digitalmente) pela Microsoft Store e a opção de permitir o carregamento de imagens assinadas pela Microsoft Store esteja selecionada.

### <a name="configuration-options"></a>Opções de configuração

Também permitir o carregamento de imagens assinadas pela **Microsoft Store** - Os aplicativos distribuídos pela Microsoft Store serão assinados digitalmente pela Microsoft Store e adicionar essa configuração permitirá que binários que passaram pelo processo de certificação da loja sejam carregados pelo aplicativo.

**Somente auditoria** - Você pode habilitar essa mitigação no modo de auditoria para medir o impacto potencial da compatibilidade em um aplicativo. Os eventos de auditoria podem ser exibidos no visualizador de eventos ou usando a Busca Avançada no [Microsoft Defender para Ponto de Extremidade.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="control-flow-guard-cfg"></a>Proteção de fluxo de controle (CFG)

### <a name="description"></a>Descrição

O CfG reduz o risco de invasores usarem vulnerabilidades de corrupção de memória protegendo chamadas de função indireta. Por exemplo, um invasor pode usuária de uma vulnerabilidade de estouro de buffer para substituir a memória que contém um ponteiro de função e substituir esse ponteiro de função por um ponteiro para o código executável de sua escolha (que também pode ter sido injetado no programa).

Essa mitigação é fornecida injetando outra verificação no momento da compilação. Antes de cada chamada de função indireta, outras instruções são adicionadas que verificam se o destino é um destino de chamada válido antes de ser chamado. Se o destino não for um destino de chamada válido, o aplicativo será encerrado. Dessa forma, somente aplicativos compilados com suporte a CFG podem se beneficiar dessa mitigação.

A verificação de um destino válido é fornecida pelo kernel do Windows. Quando os arquivos executáveis são carregados, os metadados para destinos de chamada indireta são extraídos no tempo de carregamento e marcados como destinos de chamada válidos. Além disso, quando a memória é alocada e marcada como executável (como para código gerado), esses locais de memória também são marcados como destinos de chamada válidos, para dar suporte a mecanismos como compilação JIT.

### <a name="compatibility-considerations"></a>Considerações sobre compatibilidade

Como os aplicativos devem ser compilados para dar suporte ao CFG, eles declaram implicitamente sua compatibilidade com ele. A maioria dos aplicativos, portanto, deve trabalhar com essa mitigação habilitada. Como essas verificações são compiladas no binário, a configuração que você pode aplicar é simplesmente desabilitar verificações no kernel do Windows. Em outras palavras, a mitigação está em ação por padrão, mas você pode configurar o kernel do Windows para sempre retornar "sim" se você determinar posteriormente que há um problema de compatibilidade que o desenvolvedor de aplicativos não descobriu em seus testes, o que deve ser raro.

### <a name="configuration-options"></a>Opções de configuração

**Use CFG** estrito - No modo estrito, todos os binários carregados no processo devem ser compilados para o Control Flow Guard (ou não têm nenhum código executável neles - como dlls de recursos) para serem carregados.

> [!Note]
> **O control flow guard** não tem modo de auditoria. Binários são compilados com essa mitigação habilitada.

## <a name="data-execution-prevention-dep"></a>Prevenção de Execução de Dados (DEP)

### <a name="description"></a>Descrição

A PREVENÇÃO de execução de dados (DEP) impede que a memória que não foi alocada explicitamente como executável seja executada. A DEP ajuda a proteger contra um invasor que injeta código mal-intencionado no processo, como por meio de um estouro de buffer e, em seguida, executando esse código.

Se você tentar definir o ponteiro de instrução para um endereço de memória não marcado como executável, o processador lançará uma exceção (violação de proteção geral), fazendo com que o aplicativo falha.

### <a name="compatibility-considerations"></a>Considerações sobre compatibilidade

Todos os executáveis x64, ARM e ARM-64 têm o DEP habilitado por padrão e não podem ser desabilitados. Como um aplicativo nunca será executado sem a DEP, a compatibilidade é assumida.

Todos os binários x86 (32 bits) têm o DEP habilitado por padrão, mas o DEP pode ser desabilitado por processo. Alguns aplicativos antigos herdáveis, normalmente aplicativos desenvolvidos antes do Windows XP SP2, podem não ser compatíveis com o DEP. Esses aplicativos normalmente geram código dinamicamente (por exemplo, compilação JIT) ou link para bibliotecas mais antigas (como versões mais antigas do ATL) que geram código dinamicamente.

### <a name="configuration-options"></a>Opções de configuração

**Habilitar a emulação thunk atl** - Essa opção de configuração desabilita a emulação thunk atl. A ATL, a ActiveX de modelos, foi projetada para ser o mais pequeno e rápido possível. Para reduzir o tamanho binário, ele usaria uma técnica chamada *thunking*. O thunking normalmente é pensado para interagir entre aplicativos de 32 e 16 bits, mas não há componentes de 16 bits para ATL aqui. Em vez disso, para otimizar o tamanho binário, a ATL armazenará o código do computador na memória que não esteja alinhado a palavras (criando um binário menor) e invocará esse código diretamente. Os componentes ATL compilados com Visual Studio 7.1 ou anteriores (Visual Studio 2003) não alocam essa memória como executável - a emulação thunk resolve esse problema de compatibilidade. Os aplicativos que têm um modelo de extensão binária (como o Internet Explorer 11) geralmente precisarão ter a emulação thunk ATL habilitada.

## <a name="disable-extension-points"></a>Desabilitar pontos de extensão

### <a name="description"></a>Descrição

Essa mitigação desabilita vários pontos de extensão de um aplicativo, que podem ser usados para estabelecer persistência ou elevar privilégios de conteúdo mal-intencionado.

Isso inclui:

- **AppInit DLLs** - Sempre que um processo é iniciado, o sistema carrega a DLL especificada para o contexto do processo recém-iniciado antes de chamar sua função de ponto de entrada. [Detalhes sobre DLLs appInit podem ser encontrados aqui](https://docs.microsoft.com/windows/win32/winmsg/about-window-classes#application-global-classes). Com essa mitigação aplicada, as DLLs appInit não são carregadas. A partir do Windows 7, as DLLs appInit precisam ser assinadas digitalmente, [conforme descrito aqui](https://docs.microsoft.com/windows/win32/win7appqual/appinit-dlls-in-windows-7-and-windows-server-2008-r2). Além disso, a partir do Windows 8, as DLLs do AppInit não serão carregadas se SecureBoot estiver habilitado, conforme [descrito aqui](https://docs.microsoft.com/windows/win32/dlls/secure-boot-and-appinit-dlls).
- **IMEs herdáveis** - Um Editor de Método de Entrada (IME) permite que um usuário digite texto em um idioma que tenha mais caracteres do que pode ser representado em um teclado. Terceiros podem criar IMEs. Um IME mal-intencionado pode obter credenciais ou outras informações confidenciais dessa captura de entrada. Algumas IMEs, conhecidas como IMEs Herdadas, funcionarão apenas em aplicativos da Área de Trabalho do Windows e não em aplicativos UWP. Essa mitigação também impedirá que esse IME herdado seja carregado no aplicativo da Área de Trabalho do Windows especificado.
- **Ganchos de Eventos do Windows** - Um aplicativo pode chamar a API [SetWinEventHook](https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-setwineventhook) para registrar o interesse em um evento que está ocorrendo. Uma DLL é especificada e pode ser injetada no processo. Essa mitigação força o gancho a ser postado no processo de registro em vez de executar no processo por meio de uma DLL injetada.

### <a name="compatibility-considerations"></a>Considerações sobre compatibilidade

A maioria desses pontos de extensão são usados com pouca freqüência, portanto, o impacto da compatibilidade é geralmente pequeno, particularmente em um nível de aplicativo individual. A única consideração é se os usuários estão usando IMEs Herdadas de terceiros que não funcionarão com o aplicativo protegido.

### <a name="configuration-options"></a>Opções de configuração

Não há opções de configuração para essa mitigação.

> [!Note]
> **Desabilitar pontos de extensão** não tem modo de auditoria.

## <a name="disable-win32k-system-calls"></a>Desabilitar chamadas do sistema Win32k

### <a name="description"></a>Descrição

Win32k.sys fornece uma ampla superfície de ataque para um invasor. Como um componente do modo kernel, ele é frequentemente direcionado como um vetor de escape para aplicativos que são áreas de segurança. Essa mitigação impede chamadas em win32k.sys bloqueando que um thread se converta em um thread de GUI, que recebe acesso para invocar funções win32k. Um thread não é GUI quando criado, mas convertido na primeira chamada para win32k.sys ou por meio de uma chamada de API para [IsGuiThread](https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-isguithread).

### <a name="compatibility-considerations"></a>Considerações sobre compatibilidade

Essa mitigação foi projetada para processos que são processos não da interface do usuário dedicados. Por exemplo, muitos navegadores modernos usarão o isolamento do processo e incorporarão processos que não são da interface do usuário. Qualquer aplicativo que exibe uma GUI usando um único processo será afetado por essa mitigação.

### <a name="configuration-options"></a>Opções de configuração

**Somente auditoria** - Você pode habilitar essa mitigação no modo de auditoria para medir o impacto potencial da compatibilidade em um aplicativo. Os eventos de auditoria podem ser exibidos no visualizador de eventos ou usando a Busca Avançada no [Microsoft Defender para Ponto de Extremidade.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="do-not-allow-child-processes"></a>Não permitir processos filho

### <a name="description"></a>Descrição

Essa mitigação impede que um aplicativo cria novos aplicativos filho. Uma técnica comum usada por adversários é iniciar um processo confiável no dispositivo com entrada mal-intencionada (um ataque de "vida fora da terra"), que geralmente exige o lançamento de outro aplicativo no dispositivo. Se não houver motivos legítimos para um aplicativo iniciar um processo filho, essa mitigação atenua esse possível vetor de ataque. A mitigação é aplicada definindo uma propriedade no token de processo, que bloqueia a criação de um token para o processo filho com a mensagem de erro STATUS_CHILD_PROCESS_BLOCKED.

### <a name="compatibility-considerations"></a>Considerações sobre compatibilidade

Se o aplicativo iniciar aplicativos filho por qualquer motivo, como suporte a hiperlinks que iniciam um navegador ou um navegador externo, ou que iniciam outros utilitários no computador, essa funcionalidade será interrompida com essa mitigação aplicada.

### <a name="configuration-options"></a>Opções de configuração

**Somente auditoria** - Você pode habilitar essa mitigação no modo de auditoria para medir o impacto potencial da compatibilidade em um aplicativo. Os eventos de auditoria podem ser exibidos no visualizador de eventos ou usando a Busca Avançada no [Microsoft Defender para Ponto de Extremidade.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="export-address-filtering"></a>Exportar filtragem de endereços

### <a name="description"></a>Descrição

A filtragem de endereços de exportação (EAF) reduz o risco de código mal-intencionado olhando para a tabela de endereços de exportação de todos os módulos carregados para encontrar módulos que contenham APIs úteis para seu ataque. Essa é uma tática comum usada pelo shellcode. Para reduzir o risco de tal ataque, essa mitigação protege três módulos comumente atacados:

- ntdll.dll
- kernelbase.dll
- kernel32.dll

A mitigação protege a página de memória no [diretório de exportação que aponta para a [tabela de endereços de exportação.](https://docs.microsoft.com/windows/win32/debug/pe-format#export-address-table) Esta página de memória terá a [proteção PAGE_GUARD](https://docs.microsoft.com/windows/win32/memory/creating-guard-pages) aplicada a ela. Quando alguém tentar acessar essa memória, ela gerará uma STATUS_GUARD_PAGE_VIOLATION. A mitigação lida com essa exceção e, se a instrução de acesso não passar na validação, o processo será encerrado.

### <a name="compatibility-considerations"></a>Considerações sobre compatibilidade

Essa mitigação é principalmente um problema para aplicativos como depurador, aplicativos em áreas de segurança, aplicativos que usam DRM ou aplicativos que implementam a tecnologia anti-depuração.

### <a name="configuration-options"></a>Opções de configuração

**Validar o** acesso para módulos que são comumente abusadas por explorações - Essa opção, também conhecida como EAF+, adiciona proteções para outros módulos comumente atacados:

- `mshtml.dll`
- `flash*.ocx`
- `jscript*.ocx`
- `vbscript.dll`
- `vgx.dll`
- `mozjs.dll`
- `xul.dll`
- `acrord32.dll`
- `acrofx32.dll`
- `acroform.api`

Além disso, habilitando o EAF+, essa mitigação adiciona a proteção PAGE_GUARD à página que contém o header "MZ", os dois primeiros bytes do [header do DOS](https://docs.microsoft.com/windows/win32/debug/pe-format#ms-dos-stub-image-only)em um arquivo PE, que é outro aspecto do conteúdo de memória conhecido que o shellcode pode procurar para identificar módulos potencialmente de interesse na memória.

**Somente auditoria** - Você pode habilitar essa mitigação no modo de auditoria para medir o impacto potencial da compatibilidade em um aplicativo. Os eventos de auditoria podem ser exibidos no visualizador de eventos ou usando a Busca Avançada no [Microsoft Defender para Ponto de Extremidade.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="force-randomization-for-images-mandatory-aslr"></a>Forçar a randomização para imagens (ASLR obrigatória)

### <a name="description"></a>Descrição

A Randomização de Layout de Espaço de Endereço (ASLR) reduz o risco de um invasor usar seu conhecimento do layout de memória do sistema para executar um código que já está presente na memória do processo e já marcado como executável. Isso pode reduzir o risco de um invasor usar técnicas como ataques de retorno para libc, onde o adversário define o contexto e modifica o endereço de retorno para executar o código existente com contexto que se adéque à finalidade do adversário.

O ASLR obrigatório força uma rebase de todas as DLLs dentro do processo. Um desenvolvedor pode habilitar o ASLR usando a [opção linker /DYNAMICBASE](https://docs.microsoft.com/cpp/build/reference/dynamicbase-use-address-space-layout-randomization?view=vs-2019&preserve-view=true) e essa mitigação tem o mesmo efeito.

Quando o gerenciador de memória estiver mapeando a imagem para o processo, o ASLR obrigatório irá rebaixar à força DLLs e EXEs que não optaram por ASLR. Observe, no entanto, que esse rebasamento não tem entropia e, portanto, pode ser colocado em um local previsível na memória. Para localização rebaixada e aleatória de binários, essa mitigação deve ser emparelhada com alocações de memória [Randomize (ASLR](#randomize-memory-allocations-bottom-up-aslr)inferior para cima) .

### <a name="compatibility-considerations"></a>Considerações sobre compatibilidade

Esse impacto de compatibilidade do ASLR normalmente é restrito a aplicativos mais antigos que foram construídos usando compiladores que fizeram suposições sobre o endereço base de um arquivo binário ou despojaram informações de realocação base. Isso pode levar a erros imprevisíveis à medida que o fluxo de execução tenta ir para o local esperado, em vez do local real na memória.

### <a name="configuration-options"></a>Opções de configuração

**Não permitir imagens despojadas** - Essa opção bloqueia o carregamento de imagens que tiveram as informações de realocação despojadas. O formato de arquivo do Windows PE contém endereços absolutos, e o compilador também gera uma [tabela de realocação base que o carregador pode usar para encontrar todas as referências de memória relativas e seu deslocamento, para que eles possam ser atualizados se o binário não carregar em seu endereço base preferencial. Alguns aplicativos mais antigos retiram essas informações em builds de produção e, portanto, esses binários não podem ser rebasados. Essa mitigação impede que esses binários são carregados (em vez de permitir que eles carreguem no endereço base preferencial).

> [!Note]
> **Forçar a randomização para imagens (ASLR obrigatória)** não tem modo de auditoria.

## <a name="import-address-filtering-iaf"></a>Importar filtragem de endereços (IAF)

### <a name="description"></a>Descrição

A mitigação de filtragem de endereços de importação (IAF) ajuda a reduzir o risco de um adversário alterar o fluxo de controle de um aplicativo modificando a tabela de endereços de importação (IAT) para redirecionar para o código arbitrário da escolha do invasor quando essa função for chamada. Um invasor pode usar essa abordagem para seqüestrar o controle ou interceptar, inspecionar e potencialmente bloquear chamadas para APIs confidenciais.

As páginas de memória para todas as APIs protegidas terão a [proteção PAGE_GUARD](https://docs.microsoft.com/windows/win32/memory/creating-guard-pages) aplicada a elas. Quando alguém tentar acessar essa memória, ela gerará uma STATUS_GUARD_PAGE_VIOLATION. A mitigação lida com essa exceção e, se a instrução de acesso não passar na validação, o processo será encerrado.

Essa mitigação protege as seguintes APIs do Windows:

- `GetProcAddress`
- `GetProcAddressForCaller`
- `LoadLibraryA`
- `LoadLibraryExA`
- `LoadLibraryW`
- `LoadLibraryExW`
- `LdrGetProcedureAddress`
- `LdrGetProcedureAddressEx`
- `LdrGetProcedureAddressForCaller`
- `LdrLoadDll`
- `VirtualProtect`
- `VirtualProtectEx`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `NtProtectVirtualMemory`
- `CreateProcessA`
- `CreateProcessW`
- `WinExec`
- `CreateProcessAsUserA`
- `CreateProcessAsUserW`
- `GetModuleHandleA`
- `GetModuleHandleW`
- `RtlDecodePointer`
- `DecodePointer`

### <a name="compatibility-considerations"></a>Considerações sobre compatibilidade

Aplicativos legítimos que executam interceptação de API podem ser detectados por essa mitigação e fazer com que alguns aplicativos falham. Exemplos incluem software de segurança e compatibilidade de aplicativos.

### <a name="configuration-options"></a>Opções de configuração

**Somente auditoria** - Você pode habilitar essa mitigação no modo de auditoria para medir o impacto potencial da compatibilidade em um aplicativo. Os eventos de auditoria podem ser exibidos no visualizador de eventos ou usando a Busca Avançada no [Microsoft Defender para Ponto de Extremidade.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="randomize-memory-allocations-bottom-up-aslr"></a>Randomize alocações de memória (ASLR de baixo para cima)

### <a name="description"></a>Descrição

Alocações de memória aleatórias (ASLR de baixo para cima) adiciona entropia a relocações, portanto, sua localização é aleatória e, portanto, menos previsível. Essa mitigação exige que o ASLR obrigatório entre em vigor.

O tamanho do espaço de endereço de 32 bits coloca restrições práticas na entropia que podem ser adicionadas e, portanto, os aplicativos de 64 bits dificultam para um invasor adivinhar um local na memória.

### <a name="compatibility-considerations"></a>Considerações sobre compatibilidade

A maioria dos aplicativos compatíveis com o ASLR obrigatório (rebasamento) também é compatível com a outra entropia do ASLR de bottom-up. Alguns aplicativos podem ter problemas de truncamento de ponteiro se eles estão salvando ponteiros locais em variáveis de 32 bits (esperando um endereço base abaixo de 4 GB) e, portanto, serão incompatíveis com a opção de alta entropia (que pode ser desabilitada).

### <a name="configuration-options"></a>Opções de configuração

Não use alta **entropia** - essa opção desabilita o uso de ASLR de alta entropia, que adiciona 24 bits de entropia (1 TB de variação) à alocação inferior para aplicativos de 64 bits.

> [!Note]
> **Alocações de memória aleatórias (ASLR** inferior para cima) não tem modo de auditoria.

## <a name="simulate-execution-simexec"></a>Simular execução (SimExec)

### <a name="description"></a>Descrição

Simular execução (SimExec) é uma mitigação apenas para aplicativos de 32 bits. Isso ajuda a validar que as chamadas para APIs confidenciais retornarão às funções legítimas do chamador. Ele faz isso interceptando chamadas em APIs confidenciais e simulando a execução dessas APIs, passeando pelas instruções de idioma de assembly codificado procurando a instrução RET, que deve retornar ao chamador. Em seguida, ele inspeciona essa função e anda para trás na memória para encontrar a instrução CALL anterior para determinar se a função e a instrução CALL corresponderam e que a RET não foi interceptada.

As APIs interceptadas por essa mitigação são:

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

Se um gadget ROP for detectado, o processo será encerrado.

### <a name="compatibility-considerations"></a>Considerações sobre compatibilidade

Aplicativos que executam interceptação de API, especialmente software de segurança, podem causar problemas de compatibilidade com essa mitigação.

Essa mitigação é incompatível com a mitigação do Code Guard arbitrário.

### <a name="configuration-options"></a>Opções de configuração

**Somente auditoria** - Você pode habilitar essa mitigação no modo de auditoria para medir o impacto potencial da compatibilidade em um aplicativo. Os eventos de auditoria podem ser exibidos no visualizador de eventos ou usando a Busca Avançada no [Microsoft Defender para Ponto de Extremidade.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="validate-api-invocation-callercheck"></a>Validar invocação de API (CallerCheck)

### <a name="description"></a>Descrição

Validar invocação de API (CallerCheck) é uma mitigação para técnicas rop (programação orientada a retorno) que valida que APIs confidenciais foram chamadas de um chamador válido. Essa mitigação inspeciona o endereço de retorno passado e, em seguida, desmonta heuristicamente para trás para encontrar uma chamada acima do endereço de retorno para determinar se o destino da chamada corresponde ao parâmetro passado para a função.

As APIs interceptadas por essa mitigação são:

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

Se um gadget ROP for detectado, o processo será encerrado.

### <a name="compatibility-considerations"></a>Considerações sobre compatibilidade

Aplicativos que executam interceptação de API, especialmente software de segurança, podem causar problemas de compatibilidade com essa mitigação.

Essa mitigação é incompatível com a mitigação do Code Guard arbitrário.

### <a name="configuration-options"></a>Opções de configuração

**Somente auditoria** - Você pode habilitar essa mitigação no modo de auditoria para medir o impacto potencial da compatibilidade em um aplicativo. Os eventos de auditoria podem ser exibidos no visualizador de eventos ou usando a Busca Avançada no [Microsoft Defender para Ponto de Extremidade.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="validate-exception-chains-sehop"></a>Validar cadeias de exceção (SEHOP)

### <a name="description"></a>Descrição

Validar cadeias de exceção (SEHOP) é uma mitigação em relação à técnica de exploração de sobregravações do Manipulador de Exceção *Estruturado (SEH).* [O tratamento de exceção](https://docs.microsoft.com/windows/win32/debug/structured-exception-handling) estruturado é o processo pelo qual um aplicativo pode pedir para lidar com uma exceção específica. Manipuladores de exceção são encadeados juntos, para que, se um manipulador de exceção optar por não manipular uma exceção específica, ele poderá ser passado para o próximo manipulador de exceção na cadeia até que um decida lidar com ela. Como a lista de manipuladores é dinâmica, ela é armazenada na pilha. Um invasor pode usar uma vulnerabilidade de estouro de pilha para substituir o manipulador de exceção com um ponteiro para o código de escolha do invasor.

Essa mitigação se baseia no design do SEH, onde cada entrada SEH contém um ponteiro para o manipulador de exceção, bem como um ponteiro para o próximo manipulador na cadeia de exceção. Essa mitigação é chamada pelo despachante de exceção, que valida a cadeia SEH quando uma exceção é invocada. Verifica se:

- Todos os registros de cadeia de exceção estão dentro dos limites da pilha
- Todos os registros de exceção são alinhados
- Nenhum ponteiro do manipulador de exceção está apontando para a pilha
- Não há ponteiros para trás
- A cadeia de exceção termina em um manipulador de exceção final conhecido

Se essas validações falharem, o tratamento de exceções será anulado e a exceção não será manipulada.

### <a name="compatibility-considerations"></a>Considerações sobre compatibilidade

Os problemas de compatibilidade com o SEHOP são relativamente raros. É incomum para um aplicativo assumir uma dependência de corromper a cadeia de exceção. No entanto, alguns aplicativos são afetados pelas alterações sutis no tempo, que podem se manifesto como uma condição de corrida que revela um bug latente de vários threads no aplicativo.

### <a name="configuration-options"></a>Opções de configuração

> [!Note]
> **Validar cadeias de exceção (SEHOP)** não tem modo de auditoria.

## <a name="validate-handle-usage"></a>Validar o uso da alça

### <a name="description"></a>Descrição

*Validar o uso do* identificador é uma mitigação que ajuda a proteger contra um invasor usando uma alça existente para acessar um objeto protegido. Um [identificador](https://docs.microsoft.com/windows/win32/sysinfo/handles-and-objects) é uma referência a um objeto protegido. Se o código do aplicativo estiver fazendo referência a uma alça inválida, isso pode indicar que um adversário está tentando usar uma alça que ele gravou anteriormente (mas qual contagem de referência de aplicativo não estaria ciente). Se o aplicativo tentar usar um objeto inválido, em vez de simplesmente retornar null, o aplicativo criará uma exceção (STATUS_INVALID_HANDLE).

Essa mitigação é aplicada automaticamente aos aplicativos da Windows Store.

### <a name="compatibility-considerations"></a>Considerações sobre compatibilidade

Os aplicativos que não estavam monitorando com precisão as referências de alça e que não estavam envolvendo essas operações em manipuladores de exceção, serão potencialmente afetados por essa mitigação.

### <a name="configuration-options"></a>Opções de configuração

> [!Note]
> **Validar o uso de alça** não tem modo de auditoria.

## <a name="validate-heap-integrity"></a>Validar a integridade da pilha

### <a name="description"></a>Descrição

A *mitigação de integridade de* pilha de validação aumenta o nível de proteção de mitigações de pilha no Windows, fazendo com que o aplicativo seja encerrado se uma corrupção de pilha for detectada. As mitigações incluem:

- Impedindo que uma alça HEAP seja liberada
- Executando outra validação em headers de bloco estendido para alocações de pilha
- Verificar se as alocações de pilha já não estão sinalizadas como em uso
- Adicionar páginas de proteção a grandes alocações, segmentos de heap e subsegments acima de um tamanho mínimo

### <a name="compatibility-considerations"></a>Considerações sobre compatibilidade

Essa mitigação já é aplicada por padrão para aplicativos de 64 bits e para aplicativos de 32 bits destinados ao Windows Vista ou posterior. Aplicativos herdáveis do Windows XP ou anteriores são mais em risco, embora os problemas de compatibilidade sejam raros.

### <a name="configuration-options"></a>Opções de configuração

> [!Note]
> **Validar integridade de pilha** não tem modo de auditoria.

## <a name="validate-image-dependency-integrity"></a>Validar a integridade da dependência de imagem

### <a name="description"></a>Descrição

A *mitigação de dependência de imagem* valida ajuda a proteger contra ataques que tentam substituir o código para dlls que são vinculados estaticamente por binários do Windows. A técnica de implantação de DLL abusa do mecanismo de pesquisa do carregador para injetar código mal-intencionado, que pode ser usado para obter código mal-intencionado em execução em um contexto elevado. Quando o carregador estiver carregando um binário assinado pelo Windows e carregar todas as dlls das que o binário depende, esses binários serão verificados para garantir que eles também sejam assinados digitalmente como um binário do Windows. Se eles falharem na verificação de assinatura, a dll não será carregada e lançará uma exceção, retornando um status de STATUS_INVALID_IMAGE_HASH.

### <a name="compatibility-considerations"></a>Considerações sobre compatibilidade

Os problemas de compatibilidade são incomuns. Os aplicativos que dependem da substituição de binários do Windows por versões privadas locais serão afetados e também há um pequeno risco de revelar bugs de tempo sutis em aplicativos com vários threads.

### <a name="configuration-options"></a>Opções de configuração

**Somente auditoria** - Você pode habilitar essa mitigação no modo de auditoria para medir o impacto potencial da compatibilidade em um aplicativo. Os eventos de auditoria podem ser exibidos no visualizador de eventos ou usando a Busca Avançada no [Microsoft Defender para Ponto de Extremidade.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="validate-stack-integrity-stackpivot"></a>Validar a integridade da pilha (StackPivot)

### <a name="description"></a>Descrição

A mitigação validar a integridade da pilha *(StackPivot)* ajuda a proteger contra o ataque Pivot de Pilha, um ataque ROP em que um invasor cria uma pilha falsa na memória de pilha e, em seguida, faz o aplicativo voltar para a pilha falsa que controla o fluxo de execução.

Essa mitigação intercepta muitas APIs do Windows e inspeciona o valor do ponteiro da pilha. Se o endereço do ponteiro da pilha não se enquadrar entre a parte inferior e a parte superior da pilha, um evento será gravado e, se não estiver no modo de auditoria, o processo será encerrado.

As APIs interceptadas por essa mitigação são:

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

### <a name="compatibility-considerations"></a>Considerações sobre compatibilidade

Os aplicativos que estão usando pilhas falsas serão afetados e também há um pequeno risco de revelar bugs de tempo sutis em aplicativos com vários threads.
Aplicativos que executam interceptação de API, especialmente software de segurança, podem causar problemas de compatibilidade com essa mitigação.

Essa mitigação é incompatível com a mitigação do Code Guard arbitrário.

### <a name="configuration-options"></a>Opções de configuração

**Somente auditoria** - Você pode habilitar essa mitigação no modo de auditoria para medir o impacto potencial da compatibilidade em um aplicativo. Os eventos de auditoria podem ser exibidos no visualizador de eventos ou usando a Busca Avançada no [Microsoft Defender para Ponto de Extremidade.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)
